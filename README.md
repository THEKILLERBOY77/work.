# work.
Описание алгоритмов сортировки и поиска

В этом документе представлены определения и подробный разбор характеристик алгоритмов сортировки и поиска, реализованных в файле algorithms.js. Для каждого алгоритма указаны ключевые идеи работы, временные и пространственные сложности.

Сортировка выбором (Selection Sort)
Определение.
Сортировка выбором последовательно ищет наименьший элемент в неотсортированной части массива и обменивает его с текущим элементом. На каждом шаге две области — уже отсортированная (в начале массива) и оставшаяся неотсортированная — разделены индексом, и минимум из неотсортированной части перемещается в начало

Временная сложность. Алгоритм содержит два вложенных цикла. В худшем и среднем случаях он выполняет ~n(n − 1)/2 сравнений, поэтому время работы O(n²)
Дополнительной памяти не требуется, поэтому пространственная сложность — O(1). Сортировка выбором удобна для небольших массивов, но по времени проигрывает более продвинутым алгоритмам вроде быстрого или сортировки слиянием


Сортировка обменом (пузырьком) (Bubble Sort)
Определение.
Сортировка пузырьком многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они стоят «неправильно». Каждый проход «всплывает» крупный элемент к концу, поэтому после k‑го прохода k самых больших элементов находятся на правильных местах

Временная сложность. В худшем и среднем случаях нужно сделать ~n(n − 1)/2 сравнений и обменов, поэтому время работы O(n²)

Лучший случай (уже отсортированная последовательность) — O(n) благодаря раннему выходу по флагу. Алгоритм не требует дополнительной памяти (O(1)), но из‑за квадратичной сложности подходит лишь для небольших наборов данных

Сортировка вставками (Insertion Sort)
Определение.
Алгоритм сортировки вставками упорядочивает массив так же, как человек сортирует карты в руке: поддерживается отсортированная часть массива, и каждый новый элемент вставляется в неё в правильное место, сдвигая более крупные элементы на одну позицию вправо


Временная сложность. В худшем и среднем случаях (когда последовательность обратна упорядочена) требуется ~n(n − 1)/2 сдвигов, что даёт O(n²). В лучшем случае (уже отсортированный массив) внутренний цикл не выполняется, и время равно O(n)

Память дополнительно не используется (O(1)). Алгоритм эффективен для почти упорядоченных списков и небольших массивов

Сортировка слиянием (Merge Sort)
Определение.
Сортировка слиянием использует стратегию «разделяй и властвуй»: массив рекурсивно делится пополам до подмассива длиной 1, затем частично отсортированные массивы попарно сливаются в отсортированный список. Функция merge объединяет два упорядоченных подмассива, выбирая наименьшие элементы.

Временная сложность. На каждом уровне рекурсии массив длиной n разбивается на две части, а потом объединяется. Глубина рекурсии равна log₂ n, а слияние всех элементов на каждом уровне требует O(n) времени. В результате получаем O(n log n) во всех случаях (лучший, средний и худший). Для слияния требуется дополнительный массив, поэтому пространственная сложность O(n). Метод стабилен и хорошо работает на больших массивах.

Сортировка Шелла (Shell Sort)
Определение.
Сортировка Шелла — улучшение сортировки вставками. Она сначала сортирует элементы, которые находятся на некотором расстоянии (gap) друг от друга, затем постепенно уменьшает gap до 1. Это позволяет «двигать» элементы на большие расстояния, уменьшая количество обменов на поздних этапах

Временная сложность. Сложность зависит от последовательности выбранных промежутков. При классическом выборе gap = n/2, n/4, …, 1 худший случай — O(n²); лучшие известные последовательности дают O(n^p), где p ≈ 1.25–1.5

Для упрощения можно считать среднюю сложность ≈ O(n log n). Алгоритм выполняется на месте и требует O(1) дополнительной памяти

Быстрая сортировка (Quick Sort)
Определение.
Быстрая сортировка — метод «разделяй и властвуй»: выбирается опорный элемент (pivot), массив разделяется на элементы меньше и больше pivot, затем эти части сортируются рекурсивно. Эффективность сильно зависит от выбора опорного элемента

Временная сложность. В среднем и лучшем случаях правильный выбор pivot ведёт к делению массива примерно пополам на каждом уровне, что даёт O(n log n) сравнений. Если pivot всегда оказывается крайним (массив уже отсортирован), глубина рекурсии достигает n и общий расход — O(n²)
. Быстрая сортировка требует O(log n) дополнительного стека при рекурсивной реализации, однако может быть реализована итеративно

Пирамидальная сортировка (Heap Sort)
Определение.
Пирамидальная сортировка использует структуру данных «бинарная куча». Сначала строится max‑куча (каждый родительский элемент ≥ дочерних), затем максимальный элемент (корень) извлекается и помещается в конец массива. После извлечения выполняется heapify, чтобы восстановить свойство кучи, и процесс повторяется для уменьшенной части массива

Временная сложность. Построение кучи занимает O(n), а каждый из n − 1 шагов извлечения максимального элемента требует O(log n) для восстановления кучи. Итоговая сложность — O(n log n)
Алгоритм работает на месте (не требует дополнительного массива), но recursive heapify может требовать O(log n) стека; при итеративной реализации дополнительная память — O(1)

Последовательный (линейный) поиск (Linear Search)
Определение.
Линейный поиск проходит по массиву поэлементно, сравнивая каждый элемент с искомым значением. При совпадении возвращается индекс; если до конца массива совпадений нет, результат — «не найдено»


Временная сложность. Лучший случай — O(1), когда элемент находится в первой позиции. Средний и худший случаи требуют проверки всех n элементов, что даёт O(n). Алгоритм не использует дополнительную память (O(1))

Бинарный поиск (Binary Search)
Определение.
Бинарный поиск применяется к отсортированным массивам. Он сравнивает искомый элемент с серединой массива и на каждом шаге сокращает область поиска вдвое: если ключ меньше середины — ищет в левой части, если больше — в правой

Временная сложность. Лучший случай (ключ в середине) — O(1). В среднем и худшем случаях на каждом шаге массив делится пополам, поэтому количество шагов ~log₂ n и общая сложность O(log n)
Итеративная реализация не требует дополнительной памяти (O(1)), но рекурсивная потребляет стек глубиной O(log n)

Интерполирующий поиск (Interpolation Search)
Определение.
Интерполирующий поиск — усовершенствованный вариант бинарного поиска для массивов, где значения равномерно распределены. Вместо деления пополам, алгоритм использует линейную интерполяцию для оценки вероятной позиции элемента: pos = lo + (target − arr[lo]) × (hi − lo) / (arr[hi] − arr[lo])

Временная сложность. При равномерном распределении данных размер области поиска уменьшается быстрее, чем в бинарном поиске, поэтому средняя сложность O(log log n). Если значения распределены неравномерно (например, все элементы почти одинаковы), алгоритм может деградировать до линейного поиска с O(n) шагов

Дополнительная память не требуется (O(1))

Поиск по Фибоначчи (Fibonacci Search)

Определение. Поиск по Фибоначчи — вариант двоичного поиска, который делит массив не пополам, а по числам Фибоначчи. Сначала выбирается наименьшее число Фибоначчи Fₘ, не меньшее длины массива. Используя три соседних числа Фибоначчи (Fₘ, Fₘ₋₁, Fₘ₋₂), алгоритм исследует позицию i = min(offset + Fₘ₋₂, n − 1). В зависимости от результата сравнения ключа с arr[i] область поиска сдвигается, а числа Фибоначчи уменьшаются на одно или два значения; процесс повторяется, пока Fₘ > 1

Временная сложность. На каждой итерации размер рассматриваемого участка уменьшается как 2/3 или 1/3 от текущей длины. Решение соответствующего рекуррентного соотношения показывает, что средний и худший случаи требуют O(log n) сравнений, а лучший случай (ключ найден на первой проверке) — O(1)
. Память используется только для нескольких переменных (O(1))
. Поиск по Фибоначчи выполняет немного больше сравнений, чем бинарный, но избегает операций деления или сдвига битов, что имело значение на ранних компьютерах
